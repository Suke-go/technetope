# Apple Silicon互換性チェックリスト

このドキュメントは、Apple Silicon (ARM64) での実行時に注意すべき点と、発見された潜在的な問題点をまとめています。

## 実行モードについて

Apple Silicon Macでは、以下の2つの実行モードが考えられます：

1. **ネイティブARM64モード**: ARM64バイナリとして直接実行（推奨、高速）
2. **Rosetta2モード**: x86_64バイナリをRosetta2でエミュレーション実行（互換性重視、やや低速）

**注意**: 依存ライブラリ（特にRealSense SDK）がx86_64版しか提供されていない場合、Rosetta2モードでの実行が必須になります。この場合、浮動小数点演算はx86_64の挙動になります。

## 確認済みの問題点と対処

### 1. 浮動小数点比較のepsilon値

**問題**: 固定のepsilon値（1e-6）を使用しているが、ARM64とx86_64（Rosetta2経由含む）で浮動小数点演算の結果が微妙に異なる可能性があります。

**影響箇所**:
- `FloorPlaneEstimator.cpp`: `kEpsilon = 1e-6`
- `HumanDetector.cpp`: `kEpsilon = 1e-6`
- `CalibrationPipeline.cpp`: 行列式チェックで `1e-6` を使用
- `ToioCoordinateTransform.cpp`: `1e-6` を使用

**Rosetta2での実行を考慮**:
- Rosetta2経由でx86_64バイナリを実行する場合、浮動小数点演算はx86_64の挙動になります
- ネイティブARM64とRosetta2の両方で動作する必要がある場合、より大きな許容誤差が必要です

**推奨対処**:
- より大きなepsilon値（1e-5など）を使用して、プラットフォーム間の差異を吸収
- または、プラットフォーム検出を行い、適切な値を設定
  ```cpp
  #if defined(__aarch64__) || defined(__arm64__)
    constexpr double kEpsilon = 1e-5;  // ARM64用に少し緩和
  #else
    constexpr double kEpsilon = 1e-6;  // x86_64用
  #endif
  ```

### 2. メモリアライメント

**問題**: ARMアーキテクチャはメモリアライメントに厳しい場合があります。

**影響箇所**:
- `FloorPlaneEstimator.cpp:124`: `depth_image.ptr<uint16_t>(y)`
- `CalibrationPipeline.cpp:368-390`: RealSenseデータの直接アクセス

**現状**: OpenCVの `ptr<T>()` メソッドは適切にアライメントを処理するため、問題ないはずです。ただし、RealSenseからのデータが適切にアライメントされているかは要確認。

**推奨対処**:
- メモリアクセスエラーが発生した場合は、データコピー（`clone()`）を使用
- 既に `clone()` を使用しているため、基本的に問題なし

### 3. 乱数生成器のスレッドセーフティ

**問題**: `FloorPlaneEstimator::Estimate()` がconstメソッドなのに、`mutable std::mt19937_64 rng_` を変更しています。

**影響箇所**:
- `FloorPlaneEstimator.h:45`: `mutable std::mt19937_64 rng_;`
- `FloorPlaneEstimator.cpp:160-162`: RANSACループ内でrng_を使用

**現状**: シングルスレッド実行では問題ありませんが、マルチスレッド環境では競合状態が発生する可能性があります。

**推奨対処**:
- マルチスレッド使用時は、各スレッド用にrng_のインスタンスを分ける
- または、`Estimate()` を非constメソッドに変更

### 4. RealSenseライブラリの互換性

**問題**: Apple Siliconでは、RealSenseライブラリのアクセスに特別な対応が必要です。

**既知の問題**:
- sudo実行が必須
- Apple Camera Assistantプロセスの停止が必要
- USB3接続の確認が必要

**対処**: `docs/apple_silicon_realsense.md` を参照

### 5. 浮動小数点演算の精度

**問題**: ARM64とx86_64（Rosetta2経由含む）で浮動小数点演算の結果が微妙に異なる可能性があります。

**影響箇所**:
- すべての浮動小数点計算
- 特に、RANSACアルゴリズムの結果が異なる可能性
- ホモグラフィ計算、座標変換など

**Rosetta2での実行を考慮**:
- Rosetta2経由の実行では、x86_64の浮動小数点演算挙動になります
- ネイティブARM64とRosetta2で同じシード値でも結果が異なる可能性があります
- これは正常な動作であり、プラットフォーム間の許容誤差として扱う必要があります

**推奨対処**:
- テスト時に許容誤差を適切に設定（1e-5程度）
- デバッグ時は、同じシード値を使用して再現性を確保
- 本番環境では、どちらかのアーキテクチャに統一することを推奨

### 6. 時間関連の処理

**問題**: `std::chrono` の精度がプラットフォーム間で異なる可能性があります。

**影響箇所**:
- `HumanDetector.cpp`: 時間重み付き速度計算
- `CalibrationSession.cpp`: タイムスタンプ処理

**現状**: `std::chrono::system_clock` はプラットフォーム間で一貫性があるため、問題ないはずです。

### 7. JSON数値の読み取り

**問題**: JSONからの数値読み取りで、精度の問題が発生する可能性があります。

**影響箇所**:
- `monitor_human_detection.cpp`: `jsonToMat()` 関数
- すべてのJSON設定ファイル読み込み

**現状**: `nlohmann::json` は適切に処理するため、問題ないはずです。

### 8. 型変換とキャスト

**問題**: プラットフォーム間で型のサイズが異なる可能性（64bitでは問題ないはず）

**影響箇所**:
- `size_t` の使用（64bit環境では問題ない）
- `static_cast<int>()` でのサイズ変換

**現状**: すべて64bit環境を想定しているため、問題ないはずです。

## テスト推奨事項

1. **浮動小数点演算のテスト**
   - 同じ入力データで、ネイティブARM64とRosetta2(x86_64)の結果を比較
   - 許容誤差を適切に設定（1e-5程度）
   - 同じシード値でのRANSAC結果の差異を確認

2. **メモリアクセスのテスト**
   - 大きな深度画像でのメモリアクセスエラーの確認
   - アライメントエラーの確認
   - ネイティブARM64とRosetta2の両方でテスト

3. **RealSense接続のテスト**
   - sudo実行での動作確認
   - USB3接続での動作確認
   - カメラプロセス停止後の動作確認
   - **重要**: RealSense SDKがx86_64版しかない場合、Rosetta2モードでの実行が必須

4. **パフォーマンステスト**
   - ネイティブARM64での実行時間の確認
   - Rosetta2モードでの実行時間の確認（通常1.5-2倍程度遅い）
   - メモリ使用量の確認

5. **ビルドアーキテクチャの確認**
   ```bash
   # 現在のアーキテクチャを確認
   file build/capture_calibration
   # または
   arch
   # または
   uname -m
   
   # Rosetta2で実行する場合
   arch -x86_64 ./build/capture_calibration
   ```

## 修正が必要な可能性がある箇所

1. **浮動小数点比較のepsilon値**
   - プラットフォーム固有の適切な値に調整
   - または、より大きな許容誤差を使用（1e-5推奨）
   - Rosetta2での実行も考慮して、より寛容な値に設定

2. **乱数生成器のスレッドセーフティ**
   - マルチスレッド使用時に対応

3. **エラーハンドリングの強化**
   - プラットフォーム固有のエラー処理を追加
   - 実行アーキテクチャの検出とログ出力

4. **ビルド設定の明確化**
   - CMakeLists.txtでアーキテクチャの明示的な指定
   - ネイティブARM64とRosetta2の両方でビルド・テスト可能にする

## Rosetta2での実行に関する注意事項

### RealSense SDKの互換性

**問題**: RealSense SDKの一部のバージョンやビルドがx86_64版しか提供していない場合があります。

**対処**:
- Homebrewでインストールした場合、通常はネイティブARM64版が提供されます
- 公式DMGからインストールした場合、x86_64版の可能性があります
- 実行時に `arch` コマンドで確認：
  ```bash
  # ネイティブARM64で実行
  ./build/capture_calibration
  
  # Rosetta2で実行（x86_64バイナリの場合）
  arch -x86_64 ./build/capture_calibration
  ```

### パフォーマンスへの影響

- Rosetta2での実行は、ネイティブARM64より1.5-2倍程度遅くなります
- リアルタイム処理が必要な場合は、ネイティブARM64での実行を推奨
- ただし、依存ライブラリの互換性が優先される場合は、Rosetta2での実行も許容範囲内

### 浮動小数点演算の挙動

- Rosetta2経由の実行では、x86_64の浮動小数点演算挙動になります
- ネイティブARM64と結果が異なる可能性がありますが、許容誤差の範囲内です
- テスト時は、どちらかのアーキテクチャに統一することを推奨

## 参考資料

- `docs/apple_silicon_realsense.md`: RealSenseライブラリの互換性問題
- `TESTING.md`: テスト手順

